<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Welsh Vocab Trainer</title>

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="vocabstyles.css" />

  <!-- PapaParse for CSV loading -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="./navbar.js" defer></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=BBH+Bogle&family=BBH+Hegarty&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Roboto+Slab:wght@100..900&family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

 
</head>

<body class="min-h-screen text-slate-900" data-current="Practice">
  <div id="app" class="min-h-screen flex flex-col text-[16px] md:text-[17px]">
   <div id="navbarMount"></div>
  
    <!-- Onboarding -->
    <section id="onboard" class="max-w-6xl mx-auto p-4 mt-3">
      <div class="panel rounded-2xl p-4 flex items-start gap-3">
        <div class="text-2xl">üí°</div>
        <div class="text-sm text-slate-700">
          <div class="font-medium mb-1">Vocab practice</div>
          <ol class="list-decimal ml-5 leading-relaxed">
            <li>Use <b>Study mode</b> in <b>Filters</b> to switch between <b>Learn</b> (flashcards) and <b>Test</b>.</li>
            <li>Use <b>Course</b>, <b>Unit</b>, <b>Word category</b>, or <b>Search</b> to narrow the set.</li>
            <li>In <b>Test</b>, type the Welsh answer (or pick from options in Easy mode) then press <b>Check</b>.</li>
            <li>Use <b>Skip</b> to reveal and move on (counts as wrong).</li>
            <li>In <b>Learn</b>, audio plays first (when allowed), then flip (click or Space) and rate Again/Good.</li>
          </ol>
          <div class="mt-3 flex gap-2">
            <button id="onboardFilters" class="btn btn-primary shadow">Open filters</button>
            <button id="onboardDismiss" class="btn btn-ghost">Got it</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Main panels -->
    <main id="main" class="grow max-w-6xl mx-auto p-4 pb-24 md:pb-4">
      <div id="practiceView" class="grid md:grid-cols-3 gap-4 items-start">
        <!-- Left: practice card -->
        <div class="md:col-span-2 panel rounded-2xl p-6 md:p-7">
          <div id="practiceCard"></div>
        </div>

        <!-- Right: filters + session -->
        <div class="md:col-span-1 flex flex-col gap-4">

          <!-- NOTE: filters are visible by default -->
          <div id="filtersPanel" class="panel rounded-2xl p-4">
            <!-- Admin tools -->
            <div id="adminPanel" class="hidden mb-4">
              <div class="text-sm font-medium mb-2">Admin tools</div>
              <label class="text-sm font-medium">CSV URL </label>
              <div class="mt-2 flex gap-2">
                <input id="dataUrl" class="w-full border rounded-xl px-3 py-2" placeholder="Paste CSV URL">
                <button id="btnLoadUrl" class="btn btn-primary px-4 py-2">LOAD</button>
              </div>
              <div class="mt-3">
                <div class="text-sm font-medium mb-1">Load local CSV</div>
                <input id="fileCsv" type="file" accept=".csv" />
              </div>
              <hr class="my-4" />
            </div>

            <div class="text-sm font-medium mb-2">Filters</div>

            <!-- Study / mode controls -->
            <div class="mb-4">
              <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Study mode</div>
              <div class="seg">
                <button id="studyTest" class="seg-btn">TEST</button>
                <button id="studyLearn" class="seg-btn">LEARN</button>
              </div>
            </div>

            <div class="mb-4" data-show-for="learn">
              <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Learn order</div>
              <div class="seg">
                <button id="reviewRandom" class="seg-btn">RANDOM</button>
                <button id="reviewSmart" class="seg-btn">SMART</button>
              </div>
              <div class="mt-1 text-xs text-slate-500">Smart uses your Leitner boxes (Again/Good) to prioritise review.</div>
            </div>

            <div class="mb-4" data-show-for="learn">
              <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Front of card</div>
              <div class="seg">
                <button id="frontWelsh" class="seg-btn">WELSH</button>
                <button id="frontEnglish" class="seg-btn">ENGLISH</button>
              </div>
            </div>

            <div class="mb-4" data-show-for="test">
              <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Input</div>
              <div class="seg">
                <button id="inputHard" class="seg-btn">HARD</button>
                <button id="inputEasy" class="seg-btn">EASY</button>
              </div>
            </div>

            <div class="grid gap-3 text-sm">
              <div>
                <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Course</div>
                <select id="courseSelect" class="w-full border rounded-xl px-3 py-2 bg-white"></select>
              </div>

              <div>
                <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Unit</div>
                <select id="unitSelect" class="w-full border rounded-xl px-3 py-2 bg-white"></select>
              </div>

              <div>
                <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Word category</div>
                <div id="wcBtns" class="flex flex-wrap gap-1"></div>
              </div>

              <div>
                <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">Search tags / English</div>
                <input id="searchBox" class="w-full border rounded-xl px-3 py-2" placeholder="e.g. food, travel, rights, work" />
              </div>

              <div class="flex gap-2">
                <button id="btnClearFilters" class="btn btn-ghost px-3 py-2">Clear</button>
              </div>
            </div>
          </div>

          <aside id="sessionPanel" class="panel rounded-2xl p-4">
            <div class="text-sm font-medium mb-2">Session</div>
            <div id="accBig" class="text-5xl md:text-6xl font-semibold">0%</div>
            <div id="accText" class="text-sm text-slate-600">0 / 0 correct</div>
            <div id="cardPos" class="text-sm text-slate-600">Card 0 / 0</div>

            <div class="mt-3 text-sm">
              <div class="text-xs uppercase tracking-wide text-slate-500 mb-1">By course</div>
              <ul id="byCourse" class="space-y-1"></ul>
            </div>

            <div class="mt-3 flex gap-2">
              <button id="btnResetStats" class="btn btn-ghost px-3 py-1.5">Reset stats</button>
            </div>
          </aside>
        </div>
      </div>

      <div id="browseView" class="hidden panel rounded-2xl overflow-hidden">
        <table class="w-full text-sm">
          <thead class="bg-slate-100 text-slate-700">
            <tr id="browseHead"></tr>
          </thead>
          <tbody id="browseBody"></tbody>
        </table>
      </div>

      <div id="statsView" class="hidden grid md:grid-cols-2 gap-4">
        <div class="panel rounded-2xl p-6">
          <h2 class="text-lg font-medium mb-2">Accuracy</h2>
          <div id="statsAcc" class="text-5xl font-bold">0%</div>
          <div id="statsText" class="text-slate-600">0 correct out of 0</div>
          <button id="btnResetStats2" class="mt-4 btn btn-ghost px-3 py-1.5">Reset</button>
        </div>
        <div class="panel rounded-2xl p-6">
          <h2 class="text-lg font-medium mb-2">By course</h2>
          <ul id="statsByCourse" class="space-y-1 text-sm"></ul>
        </div>
      </div>
    </main>

    <!-- Mobile action bar -->
    <div id="mobileBar" class="fixed md:hidden bottom-0 inset-x-0 bg-white/95 backdrop-blur border-t shadow-lg p-2">
      <div class="max-w-6xl mx-auto flex gap-2">
        <button id="mbHint" title="Hint/Hear" class="flex-1 btn btn-ghost px-3 py-2">Hint</button>
        <button id="mbCheck" title="Check/Next" class="flex-1 btn btn-primary px-3 py-2">Check</button>
        <button id="mbNext" title="Skip" class="flex-1 btn btn-ghost px-3 py-2">Skip</button>
      </div>
    </div>

    <footer class="max-w-6xl mx-auto p-6 text-xs text-slate-500">
      <div class="flex flex-wrap gap-4 items-center">
        <span>¬© Hyffordwr Cymraeg</span>
        <button id="btnTop" class="ml-auto btn btn-ghost px-2 py-1">Back to top</button>
      </div>
    </footer>
  </div>

<script>
/* ========= Utilities ========= */
function shuffleInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

const $ = (sel, root = document) => root.querySelector(sel);
const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

function normalize(s) {
  return (s || "")
    .toString()
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .replace(/‚Äô/g, "'")
    .toLowerCase()
    .trim()
    .replace(/\s+/g, " ");
}
function esc(s) {
  return (s == null ? "" : String(s)).replace(/[&<>"]/g, ch => ({
    "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;"
  }[ch]));
}
function getParam(k) { return new URLSearchParams(location.search).get(k); }
function saveLS(k, v) { try { localStorage.setItem(k, JSON.stringify(v)); } catch (e) {} }
function loadLS(k, d) { try { const r = localStorage.getItem(k); return r ? JSON.parse(r) : d; } catch (e) { return d; } }

function toggleBtn(text, active, onToggle) {
  const b = document.createElement("button");
  b.type = "button";
  b.className = `pill ${active ? "pill-on" : ""}`;
  b.textContent = text;
  b.onclick = () => onToggle(!active);
  return b;
}

/* ========= Practice mode (Random / Smart - Leitner) ========= */
const PRACTICE_MODE_LS_KEY = "vocab_practice_mode_v1";
const LEITNER_LS_KEY = "vocab_leitner_boxes_v1";
const LEITNER_MAX_BOX = 5;
const LEITNER_WEIGHTS = [0, 50, 25, 15, 7, 3]; // index 1..5

function clampBox(n) {
  const x = Number(n);
  if (!Number.isFinite(x)) return 1;
  return Math.max(1, Math.min(LEITNER_MAX_BOX, Math.round(x)));
}
function getBoxFor(cardId) {
  return clampBox(state.leitner?.[cardId] ?? 1);
}
function setBoxFor(cardId, box) {
  if (!state.leitner) state.leitner = {};
  state.leitner[cardId] = clampBox(box);
  saveLS(LEITNER_LS_KEY, state.leitner);
}
function updateLeitner(cardId, result) {
  const cur = getBoxFor(cardId);
  const next = (result === "correct") ? Math.min(LEITNER_MAX_BOX, cur + 1) : 1;
  setBoxFor(cardId, next);
}
function weightedPickBox(candidatesByBox) {
  let total = 0;
  for (let b = 1; b <= LEITNER_MAX_BOX; b++) {
    if (candidatesByBox[b]?.length) total += LEITNER_WEIGHTS[b];
  }
  if (!total) return 1;
  let r = Math.random() * total;
  for (let b = 1; b <= LEITNER_MAX_BOX; b++) {
    if (!candidatesByBox[b]?.length) continue;
    r -= LEITNER_WEIGHTS[b];
    if (r <= 0) return b;
  }
  return 1;
}
function pickNextSmartIdx() {
  const n = state.filtered?.length || 0;
  if (!n) return 0;

  if (!Array.isArray(state.smartQueue)) state.smartQueue = [];

  if (state.smartQueue.length) {
    state.smartQueue.forEach(item => item.dueAfter = Math.max(0, (item.dueAfter || 0) - 1));
    const duePos = state.smartQueue.findIndex(item => (item.dueAfter || 0) === 0 && item.idx !== state.smartIdx);
    if (duePos >= 0) {
      const item = state.smartQueue.splice(duePos, 1)[0];
      return item.idx;
    }
  }

  const byBox = { 1: [], 2: [], 3: [], 4: [], 5: [] };
  for (let i = 0; i < n; i++) {
    const id = state.filtered[i]?.CardID || `row_${i}`;
    const box = getBoxFor(id);
    byBox[box].push(i);
  }

  let chosenBox = weightedPickBox(byBox);
  if (!byBox[chosenBox].length) {
    for (let b = 1; b <= LEITNER_MAX_BOX; b++) {
      if (byBox[b].length) { chosenBox = b; break; }
    }
  }

  const pool = byBox[chosenBox] || [];
  if (!pool.length) return Math.floor(Math.random() * n);

  let idx = pool[Math.floor(Math.random() * pool.length)];
  for (let tries = 0; tries < 6 && idx === state.smartIdx && pool.length > 1; tries++) {
    idx = pool[Math.floor(Math.random() * pool.length)];
  }
  return idx;
}

/* ========= TTS (Polly via Lambda URL) ========= */
const POLLY_FUNCTION_URL = "https://pl6xqfeht2hhbruzlhm3imcpya0upied.lambda-url.eu-west-2.on.aws/";
const ttsCache = new Map();

/* Reusable audio element = better autoplay behaviour + no overlaps */
const ttsAudio = new Audio();
ttsAudio.preload = "auto";

function buildCompleteSentence(card, answerOverride = null) {
  const before = (card.BeforeCY || "").trimEnd();
  const answer = (answerOverride != null ? answerOverride : (card.AnswerCY || "")).trim();
  const after  = (card.AfterCY || "").trimStart();
  let s = [before, answer, after].filter(Boolean).join(" ");
  s = s.replace(/\s+/g, " ").trim();
  s = s.replace(/\s+([,.;:!?])/g, "$1");
  return s;
}

async function playPollySentence(sentence) {
  if (!sentence) throw new Error("No sentence to speak.");

  // Stop any previous playback
  try { ttsAudio.pause(); } catch(e) {}
  try { ttsAudio.currentTime = 0; } catch(e) {}

  let url = ttsCache.get(sentence) || null;

  if (!url) {
    const res = await fetch(POLLY_FUNCTION_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: sentence })
    });

    if (!res.ok) {
      const msg = await res.text().catch(() => "");
      throw new Error(msg || `TTS failed (${res.status})`);
    }

    const ct = (res.headers.get("content-type") || "").toLowerCase();

    if (ct.includes("audio") || ct.includes("octet-stream")) {
      const buf = await res.arrayBuffer();
      const blob = new Blob([buf], { type: "audio/mpeg" });
      url = URL.createObjectURL(blob);
    } else {
      const j = await res.json();
      if (j.url) url = j.url;
      else if (j.audioBase64 || j.audioContent) {
        const b64 = j.audioBase64 || j.audioContent;
        const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        const blob = new Blob([bytes], { type: "audio/mpeg" });
        url = URL.createObjectURL(blob);
      } else {
        throw new Error("TTS response didn't include audio.");
      }
    }

    ttsCache.set(sentence, url);
  }

  ttsAudio.src = url;
  ttsAudio.load();

  // If autoplay is blocked, this throws NotAllowedError
  await ttsAudio.play();
}

/* ========= ‚Äú?‚Äù popover UI ========= */
function mountInfoPopover(hostEl, htmlBody, ariaLabel = "Help") {
  if (!hostEl) return;
  if (!htmlBody || !String(htmlBody).trim()) return;

  hostEl.style.position = "relative";

  const btn = document.createElement("button");
  btn.type = "button";
  btn.className = "base-info-btn";
  btn.textContent = "?";
  btn.setAttribute("aria-label", ariaLabel);
  btn.setAttribute("title", ariaLabel);

  const pop = document.createElement("div");
  pop.className = "base-info-popover hidden animate-pop";
  pop.setAttribute("role", "dialog");

  const close = document.createElement("button");
  close.type = "button";
  close.className = "base-info-close";
  close.setAttribute("aria-label", "Close");
  close.textContent = "√ó";

  pop.innerHTML = htmlBody;
  pop.appendChild(close);

  btn.addEventListener("click", (e) => {
    e.stopPropagation();
    const isHidden = pop.classList.contains("hidden");
    $$(".base-info-popover").forEach(p => p.classList.add("hidden"));
    if (isHidden) pop.classList.remove("hidden");
    else pop.classList.add("hidden");
  });

  close.addEventListener("click", (e) => {
    e.stopPropagation();
    pop.classList.add("hidden");
  });

  pop.addEventListener("click", (e) => e.stopPropagation());

  hostEl.appendChild(btn);
  hostEl.appendChild(pop);
}
document.addEventListener("click", () => $$(".base-info-popover").forEach(p => p.classList.add("hidden")));
document.addEventListener("keydown", (e) => { if (e.key === "Escape") $$(".base-info-popover").forEach(p => p.classList.add("hidden")); });

/* ========= Data loading ========= */
function getVal(row, names) {
  const keys = Object.keys(row || {});
  for (const key of keys) {
    if (names.some(n => key.trim().toLowerCase() === n.trim().toLowerCase())) {
      return (row[key] ?? "").toString();
    }
  }
  return "";
}

function coerceRow(r) {
  const row = r || {};

  const answerCY = getVal(row, ["AnswerCY","Answer","Welsh","Answer (CY)"]).trim();

  const acceptedRaw = getVal(row, [
    "AcceptedAnswerArray","Accepted Answer Array","AcceptedAnswers","Accepted Answers",
    "AnswerArray","Answer Array","Answers"
  ]).trim();

  const optionsRaw = getVal(row, [
    "OptionsArray","Options Array","Options","MCQOptions","ChoiceOptions"
  ]).trim();

  const parsePipe = (raw) =>
    (raw ? raw.split("|") : []).map(s => (s || "").trim()).filter(Boolean);

  let accepted = parsePipe(acceptedRaw);
  if (answerCY) accepted = [answerCY, ...accepted.filter(a => normalize(a) !== normalize(answerCY))];

  let options = parsePipe(optionsRaw);
  if (answerCY && !options.map(normalize).includes(normalize(answerCY))) options.unshift(answerCY);

  return {
    CardID: getVal(row, ["CardID","CardId","ID","Id"]).trim(),
    Course: getVal(row, ["Course"]).trim(),
    Unit: getVal(row, ["Unit"]).trim(),
    WordCategoryEN: getVal(row, ["WordCategoryEN","WordCategoryEn"]).trim(),
    WordCategoryCY: getVal(row, ["WordCategoryCY","WordCategoryCy"]).trim(),
    BaseCY: getVal(row, ["BaseCY","Base CY","BaseCy"]).trim(),
    BaseEN: getVal(row, ["BaseEN","Base EN","BaseCy"]).trim(),
    NotesEN: getVal(row, ["NotesEN","NotesEn"]).trim(),
    NotesCY: getVal(row, ["NotesCY","NotesCy"]).trim(),
    HintCY: getVal(row, ["HintCY","Hint CY"]).trim(),
    BeforeCY: getVal(row, ["BeforeCY","Before CY","Before"]).trim(),
    AfterCY: getVal(row, ["AfterCY","After CY","After"]).trim(),
    SentenceHelpEN: getVal(row, ["SentenceHelpEN","Sentence Help EN","SentenceHelpEn","Sentence Help En"]).trim(),
    SentenceHelpCY: getVal(row, ["SentenceHelpCY","Sentence Help CY","SentenceHelpCy","Sentence Help Cy"]).trim(),
    AnswerCY: answerCY,
    AcceptedAnswerArray: accepted,
    OptionsArray: options,
    AnswerArray: accepted, // back-compat
    WhyEN: getVal(row, ["WhyEN","Why EN","Why"]).trim(),
    WhyCY: getVal(row, ["WhyCY","Why CY"]).trim(),
    TagsEN: getVal(row, ["TagsEN","TagsEn"]).trim(),
    TagsCY: getVal(row, ["TagsCY","TagsCy"]).trim()
  };
}

async function loadCsvUrl(u) {
  return new Promise((resolve, reject) => {
    Papa.parse(u, {
      download: true,
      header: true,
      skipEmptyLines: true,
      complete: (res) => resolve(res.data),
      error: reject
    });
  });
}

/* Default: single CSV (no index.json required) */
const DEFAULT_CSV_URL = "data/vocab/cards.csv";
const FALLBACK_CSV_URL = "https://katyjohannab.github.io/welsh-mutation-trainer/data/vocab/cards.csv";
async function loadDefaultCsv() {
  try { return await loadCsvUrl(DEFAULT_CSV_URL); }
  catch (e) { return await loadCsvUrl(FALLBACK_CSV_URL); }
}

/* ========= App State ========= */
const state = {
  rows: [],
  filtered: [],
  mode: loadLS("vocab_mode", "practice"),
  studyMode: loadLS("vocab_study_mode_v1", "test"),
  learnFront: loadLS("vocab_learn_front_v1", "cy"),
  learnFlipped: false,
  learnFrontReady: false,
  learnAutoplayBlocked: false,
  learnActiveKey: null,
  learnToken: 0,
  currentShownIdx: 0,

  /* NEW: autoplay gate (audio only after user gesture succeeds once) */
  audioEnabled: loadLS("vocab_audio_enabled_v1", false),

  diffPreset: loadLS("vocab_diff", "all"),
  course: loadLS("vocab_course", ""),
  unit: loadLS("vocab_unit", ""),
  wordCats: loadLS("vocab_wc", []),
  search: loadLS("vocab_search", ""),

  practiceMode: loadLS(PRACTICE_MODE_LS_KEY, "shuffle"),
  inputMode: loadLS("vocab_input_mode_v1", "hard"),
  leitner: loadLS(LEITNER_LS_KEY, {}),
  smartIdx: null,
  smartCount: 0,
  smartQueue: [],
  deck: [],
  p: 0,
  guess: "",
  revealed: false,
  lastResult: null,
  freezeIdx: null,
  freezePos: null,

  easyOpt: { cardKey: null, options: [] },

  history: loadLS("vocab_hist", []),
  admin: getParam("admin") === "1",

  lang: loadLS("vocab_lang", "en"),
  currentIdx: 0,
  currentDeckPos: -1,
};

const COURSE_EASY = new Set(["Mynediad","Sylfaen"]);
const COURSE_HARD = new Set(["Uwch 1","Uwch 2","Uwch 3","Uwch1","Uwch2","Uwch3"]);

function applyDiffPreset(list) {
  if (state.course) return list;
  if (state.diffPreset === "easy") return list.filter(r => COURSE_EASY.has(r.Course));
  if (state.diffPreset === "hard") return list.filter(r => COURSE_HARD.has(r.Course));
  return list;
}

function applyFilters() {
  let list = state.rows.slice();
  list = applyDiffPreset(list);

  if (state.course) list = list.filter(r => r.Course === state.course);
  if (state.unit) list = list.filter(r => r.Unit === state.unit);
  if (state.wordCats?.length) list = list.filter(r => state.wordCats.includes(r.WordCategory));

  const q = (state.search || "").trim();
  if (q) {
    const nq = normalize(q);
    list = list.filter(r => {
      const hay = [
        r.BaseEN, r.Tags, r.HintEN, r.BeforeCY, r.AfterCY, r.Course, r.Unit, r.WordCategory
      ].filter(Boolean).join(" ‚Ä¢ ");
      return normalize(hay).includes(nq);
    });
  }

  state.filtered = list;
}

function rebuildDeck() {
  const n = state.filtered.length;
  const d = Array.from({ length: n }, (_, i) => i);
  shuffleInPlace(d);
  state.deck = d;
  state.p = 0;
  state.guess = "";
  state.revealed = false;
  state.lastResult = null;
  state.freezeIdx = null;
  state.freezePos = null;
  state.smartQueue = [];
  state.easyOpt = { cardKey: null, options: [] };

  if (state.practiceMode === "smart") {
    state.smartCount = 0;
    state.smartIdx = pickNextSmartIdx();
  } else {
    state.smartIdx = null;
    state.smartCount = 0;
  }
}

/* ========= UI: Language toggle text ========= */
function applyLanguage() {
  const langBtn = $("#btnLangToggle");
  if (langBtn) {
    const nextLang = (state.lang === "en") ? "CY" : "EN";
    langBtn.innerHTML = `<span aria-hidden="true">üîÅ</span><span class="langtag">${nextLang}</span>`;
    langBtn.title = (state.lang === "en") ? "Switch to Cymraeg" : "Switch to English";
    langBtn.setAttribute("aria-label", (state.lang === "en") ? "Switch language to Cymraeg" : "Switch language to English");
  }
}

/* ========= Filters UI build ========= */
function buildFilterControls() {
  const setStudyBtnState = () => {
    const map = { test: "#studyTest", learn: "#studyLearn" };
    Object.values(map).forEach(id => $(id)?.classList.remove("is-on"));
    const activeId = map[state.studyMode] || "#studyTest";
    $(activeId)?.classList.add("is-on");
    [$("#studyTest"), $("#studyLearn")].forEach(b => b && b.setAttribute("aria-pressed", b.classList.contains("is-on") ? "true" : "false"));
  };

  const applyStudyVisibility = () => {
    const m = state.studyMode || "test";
    $$('[data-show-for]').forEach(el => {
      const showFor = (el.getAttribute('data-show-for') || '').trim();
      el.classList.toggle('hidden', showFor && showFor !== m);
    });
  };

  const resetModeSpecificState = () => {
    state.guess = "";
    state.revealed = false;
    state.lastResult = null;
    state.freezeIdx = null;
    state.freezePos = null;
    state.easyOpt = { cardKey: null, options: [] };

    state.learnFlipped = false;
    state.learnFrontReady = false;
    state.learnAutoplayBlocked = false;
    state.learnActiveKey = null;
  };

  $("#studyTest")?.addEventListener("click", () => {
    if (state.studyMode === "test") return;
    state.studyMode = "test";
    saveLS("vocab_study_mode_v1", state.studyMode);
    resetModeSpecificState();
    rebuildDeck();
    applyStudyVisibility();
    setStudyBtnState();
    render();
    setTimeout(() => $("#answerBox")?.focus(), 0);
  });

  $("#studyLearn")?.addEventListener("click", () => {
    if (state.studyMode === "learn") return;
    state.studyMode = "learn";
    saveLS("vocab_study_mode_v1", state.studyMode);
    resetModeSpecificState();
    rebuildDeck();
    applyStudyVisibility();
    setStudyBtnState();
    render();
  });

  setStudyBtnState();
  applyStudyVisibility();

  const setFrontBtnState = () => {
    const w = $("#frontWelsh"), e = $("#frontEnglish");
    if (w) w.classList.toggle("is-on", state.learnFront === "cy");
    if (e) e.classList.toggle("is-on", state.learnFront === "en");
    [w, e].forEach(b => b && b.setAttribute("aria-pressed", b.classList.contains("is-on") ? "true" : "false"));
  };
  $("#frontWelsh")?.addEventListener("click", () => {
    if (state.learnFront === "cy") return;
    state.learnFront = "cy";
    saveLS("vocab_learn_front_v1", state.learnFront);
    render();
  });
  $("#frontEnglish")?.addEventListener("click", () => {
    if (state.learnFront === "en") return;
    state.learnFront = "en";
    saveLS("vocab_learn_front_v1", state.learnFront);
    render();
  });
  setFrontBtnState();

  const setInputBtnState = () => {
    const hard = $("#inputHard"), easy = $("#inputEasy");
    if (hard) hard.classList.toggle("is-on", state.inputMode === "hard");
    if (easy) easy.classList.toggle("is-on", state.inputMode === "easy");
    [hard, easy].forEach(b => b && b.setAttribute("aria-pressed", b.classList.contains("is-on") ? "true" : "false"));
  };
  $("#inputHard")?.addEventListener("click", () => {
    if (state.inputMode === "hard") return;
    state.inputMode = "hard";
    saveLS("vocab_input_mode_v1", state.inputMode);
    state.easyOpt = { cardKey: null, options: [] };
    state.guess = "";
    state.revealed = false;
    state.lastResult = null;
    setInputBtnState();
    render();
    setTimeout(() => $("#answerBox")?.focus(), 0);
  });
  $("#inputEasy")?.addEventListener("click", () => {
    if (state.inputMode === "easy") return;
    state.inputMode = "easy";
    saveLS("vocab_input_mode_v1", state.inputMode);
    state.easyOpt = { cardKey: null, options: [] };
    state.guess = "";
    state.revealed = false;
    state.lastResult = null;
    setInputBtnState();
    render();
  });
  setInputBtnState();

  const setReviewBtnState = () => {
    const r = $("#reviewRandom"), s = $("#reviewSmart");
    if (r) r.classList.toggle("is-on", state.practiceMode === "shuffle");
    if (s) s.classList.toggle("is-on", state.practiceMode === "smart");
    [r, s].forEach(b => b && b.setAttribute("aria-pressed", b.classList.contains("is-on") ? "true" : "false"));
  };
  $("#reviewRandom")?.addEventListener("click", () => {
    if (state.practiceMode === "shuffle") return;
    state.practiceMode = "shuffle";
    saveLS("vocab_practice_mode_v1", state.practiceMode);
    rebuildDeck();
    setReviewBtnState();
    render();
  });
  $("#reviewSmart")?.addEventListener("click", () => {
    if (state.practiceMode === "smart") return;
    state.practiceMode = "smart";
    saveLS("vocab_practice_mode_v1", state.practiceMode);
    rebuildDeck();
    setReviewBtnState();
    render();
  });
  setReviewBtnState();

  const setDiffBtnState = () => {
    const map = { all:"#diffAll", easy:"#diffEasy", hard:"#diffHard" };
    Object.values(map).forEach(id => $(id)?.classList.remove("is-on"));
    const activeId = map[state.diffPreset] || "#diffAll";
    $(activeId)?.classList.add("is-on");
    [$("#diffAll"), $("#diffEasy"), $("#diffHard")].forEach(b => b && b.setAttribute("aria-pressed", b.classList.contains("is-on") ? "true" : "false"));
  };

  $("#diffAll")?.addEventListener("click", () => {
    state.diffPreset = "all";
    saveLS("vocab_diff", state.diffPreset);
    applyFilters(); rebuildDeck(); buildFilterControls(); render();
  });
  $("#diffEasy")?.addEventListener("click", () => {
    state.diffPreset = "easy";
    state.course = ""; state.unit = "";
    saveLS("vocab_diff", state.diffPreset);
    saveLS("vocab_course", state.course);
    saveLS("vocab_unit", state.unit);
    applyFilters(); rebuildDeck(); buildFilterControls(); render();
  });
  $("#diffHard")?.addEventListener("click", () => {
    state.diffPreset = "hard";
    state.course = ""; state.unit = "";
    saveLS("vocab_diff", state.diffPreset);
    saveLS("vocab_course", state.course);
    saveLS("vocab_unit", state.unit);
    applyFilters(); rebuildDeck(); buildFilterControls(); render();
  });
  setDiffBtnState();

  const courseSel = $("#courseSelect");
  const unitSel = $("#unitSelect");

  const courses = Array.from(new Set(state.rows.map(r => r.Course).filter(Boolean))).sort();
  if (courseSel) {
    courseSel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = ""; opt0.textContent = "All courses";
    courseSel.appendChild(opt0);
    courses.forEach(c => {
      const o = document.createElement("option");
      o.value = c; o.textContent = c;
      courseSel.appendChild(o);
    });
    courseSel.value = state.course || "";
    courseSel.onchange = (e) => {
      state.course = e.target.value;
      state.unit = "";
      state.diffPreset = "all";
      saveLS("vocab_course", state.course);
      saveLS("vocab_unit", state.unit);
      saveLS("vocab_diff", state.diffPreset);
      applyFilters(); rebuildDeck(); buildFilterControls(); render();
    };
  }

  const unitsBase = applyDiffPreset(state.rows.slice())
    .filter(r => !state.course || r.Course === state.course)
    .map(r => r.Unit)
    .filter(Boolean);

  const units = Array.from(new Set(unitsBase)).sort((a,b) => a.localeCompare(b, undefined, { numeric:true, sensitivity:"base" }));

  if (unitSel) {
    unitSel.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = ""; opt0.textContent = "All units";
    unitSel.appendChild(opt0);
    units.forEach(u => {
      const o = document.createElement("option");
      o.value = u; o.textContent = u;
      unitSel.appendChild(o);
    });
    unitSel.value = state.unit || "";
    unitSel.onchange = (e) => {
      state.unit = e.target.value;
      saveLS("vocab_unit", state.unit);
      applyFilters(); rebuildDeck(); render();
    };
  }

  const wcHost = $("#wcBtns");
  if (wcHost) {
    wcHost.innerHTML = "";
    const cats = Array.from(new Set(state.rows.map(r => r.WordCategory).filter(Boolean))).sort();
    const allActive = !state.wordCats?.length;

    wcHost.appendChild(toggleBtn("All", allActive, () => {
      state.wordCats = [];
      saveLS("vocab_wc", state.wordCats);
      applyFilters(); rebuildDeck(); buildFilterControls(); render();
    }));

    cats.forEach(c => {
      const active = state.wordCats.includes(c);
      wcHost.appendChild(toggleBtn(c, active, (on) => {
        state.wordCats = on ? Array.from(new Set([...state.wordCats, c])) : state.wordCats.filter(x => x !== c);
        saveLS("vocab_wc", state.wordCats);
        applyFilters(); rebuildDeck(); render();
      }));
    });
  }

  const sb = $("#searchBox");
  if (sb) {
    sb.value = state.search || "";
    sb.oninput = (e) => {
      state.search = e.target.value;
      saveLS("vocab_search", state.search);
      applyFilters(); rebuildDeck(); render();
    };
  }

  $("#btnClearFilters")?.addEventListener("click", () => {
    state.diffPreset = "all";
    state.course = "";
    state.unit = "";
    state.wordCats = [];
    state.search = "";
    saveLS("vocab_diff", state.diffPreset);
    saveLS("vocab_course", state.course);
    saveLS("vocab_unit", state.unit);
    saveLS("vocab_wc", state.wordCats);
    saveLS("vocab_search", state.search);
    applyFilters(); rebuildDeck(); buildFilterControls(); render();
  });
}

/* ========= Render ========= */
function isSmartActive() {
  return (state.studyMode === "learn") && (state.practiceMode === "smart");
}
function getShownCard() {
  const i = state.currentShownIdx || 0;
  return state.filtered[i];
}
function resetLearnStateForNewCard() {
  state.learnFlipped = false;
  state.learnFrontReady = false;
  state.learnAutoplayBlocked = false;
  state.learnActiveKey = null;
}

function setMobileBarForMode() {
  const bHint = $("#mbHint");
  const bCheck = $("#mbCheck");
  const bNext = $("#mbNext");
  if (!bHint || !bCheck || !bNext) return;

  if (state.mode === "practice" && state.studyMode === "learn") {
    bHint.textContent = "Hear";
    bCheck.textContent = "Again";
    bNext.textContent = "Good";
    bNext.disabled = false;
    bHint.disabled = false;
  } else {
    // Test mode: before reveal -> Hint / Check / Skip ; after reveal -> Hear / Next / (Skip disabled)
    if (state.revealed) {
      bHint.textContent = "Hear";
      bCheck.textContent = "Next";
      bNext.textContent = "Skip";
      bNext.disabled = true;
    } else {
      bHint.textContent = "Hint";
      bCheck.textContent = "Check";
      bNext.textContent = "Skip";
      bNext.disabled = false;
    }
    bHint.disabled = false;
  }
}

async function startLearnAutoplay(cardKey, speakText) {
  if (!cardKey) return;
  if (state.learnActiveKey === cardKey && state.learnFrontReady) return;

  // Browser policy: only autoplay after a user-initiated play has succeeded once.
  if (!state.audioEnabled) {
    state.learnActiveKey = cardKey;
    state.learnFrontReady = true;
    state.learnAutoplayBlocked = true;

    const frontTextEl = $("#learnFrontText");
    const statusEl = $("#learnStatus");

    if (frontTextEl) frontTextEl.classList.remove("is-hidden");
    if (statusEl) statusEl.textContent = "Press Hear (or A) once to enable autoplay.";
    return;
  }

  state.learnActiveKey = cardKey;
  state.learnFrontReady = false;
  state.learnAutoplayBlocked = false;

  const token = ++state.learnToken;
  const frontTextEl = $("#learnFrontText");
  const statusEl = $("#learnStatus");

  if (frontTextEl) frontTextEl.classList.add("is-hidden");
  if (statusEl) statusEl.textContent = "";

  try {
    await playPollySentence(speakText);
    if (token !== state.learnToken) return;
    state.learnFrontReady = true;
    if (frontTextEl) frontTextEl.classList.remove("is-hidden");
  } catch (e) {
    if (token !== state.learnToken) return;

    state.learnAutoplayBlocked = true;
    state.learnFrontReady = true;

    // If autoplay got blocked again, treat audio as locked until user clicks Hear.
    state.audioEnabled = false;
    saveLS("vocab_audio_enabled_v1", state.audioEnabled);

    if (frontTextEl) frontTextEl.classList.remove("is-hidden");
    if (statusEl) statusEl.textContent = "Autoplay blocked. Press Hear (or A) to enable audio.";
  }
}

function toggleLearnFlip(forceTo = null) {
  const cardEl = $("#learnCard3d");
  const next = (forceTo == null) ? !state.learnFlipped : !!forceTo;
  state.learnFlipped = next;
  if (cardEl) cardEl.classList.toggle("is-flipped", next);
}

function learnRate(isGood) {
  const card = getShownCard();
  if (!card) return;

  const idForStats = card.CardID || `row_${state.currentShownIdx}`;
  const ok = !!isGood;

  state.history = [{
    t: Date.now(),
    ok,
    cardId: idForStats,
    course: card.Course || "",
    expected: (card.BaseCY|| ""),
    got: ok ? "GOOD" : "AGAIN",
    mode: state.practiceMode,
    input: "learn",
    study: "learn"
  }, ...state.history].slice(0, 1000);
  saveLS("vocab_hist", state.history);

  updateLeitner(idForStats, ok ? "correct" : "wrong");
  if (!ok && isSmartActive()) state.smartQueue.push({ idx: state.currentShownIdx, dueAfter: 2 });

  resetLearnStateForNewCard();
  nextCard(1);
}

function renderPractice() {
  const host = $("#practiceCard");
  if (!host) return;
  host.innerHTML = "";

  const n = state.filtered.length;
  if (!n) {
    host.innerHTML = `
      <div class="text-slate-700 panel rounded-xl p-4">
        No cards match your filters.
        <button id="localClear" class="ml-2 btn btn-ghost px-2 py-1">Clear filters</button>
      </div>`;
    $("#localClear")?.addEventListener("click", () => $("#btnClearFilters")?.click());
    return;
  }

  const useSmart = isSmartActive();
  let idxNow;
  let posText = "";

  if (useSmart) {
    if (state.smartIdx == null) state.smartIdx = pickNextSmartIdx();
    idxNow = state.smartIdx;
    state.currentDeckPos = -1;
    const reviewed = (state.smartCount || 0) + 1;
    posText = `Reviewed ${reviewed} ¬∑ Pool ${n}`;
    $("#cardPos").textContent = `Smart ¬∑ ${posText}`;
  } else {
    const deckIdx = state.p % state.deck.length;
    idxNow = state.deck[deckIdx];
    state.currentDeckPos = deckIdx;
    const pos = state.deck.length ? (deckIdx + 1) : 0;
    posText = `Card ${pos} / ${state.deck.length || 0}`;
    $("#cardPos").textContent = (state.studyMode === "learn") ? `Learn ¬∑ ${posText}` : posText;
  }

  const idxShown = (state.studyMode === "test" && state.revealed && state.freezeIdx != null) ? state.freezeIdx : idxNow;
  const card = state.filtered[idxShown];
  state.currentIdx = idxNow;
  state.currentShownIdx = idxShown;

  const cardKey = card.CardID || `row_${idxShown}`;
  const wrap = document.createElement("div");

  const header = document.createElement("div");
  header.className = "flex flex-wrap items-center justify-between gap-2 mb-3";
  const headerLeft = document.createElement("div");
  headerLeft.className = "flex flex-wrap items-center gap-2 text-xs text-slate-500";
  headerLeft.textContent = posText;
  header.append(headerLeft);

  const activeFilters = document.createElement("div");
  activeFilters.className = "flex flex-wrap gap-2 mb-4";
  const chip = (txt) => { const s = document.createElement("span"); s.className = "chip"; s.textContent = txt; return s; };
  if (state.diffPreset && state.diffPreset !== "all") activeFilters.appendChild(chip(`Preset: ${state.diffPreset}`));
  if (state.course) activeFilters.appendChild(chip(state.course));
  if (state.unit) activeFilters.appendChild(chip(state.unit));
  if (state.wordCats?.length) state.wordCats.forEach(c => activeFilters.appendChild(chip(c)));
  if ((state.search || "").trim()) activeFilters.appendChild(chip(`Search: ${state.search.trim()}`));
  const hasAnyFilters = activeFilters.childElementCount > 0;

  /* ===== LEARN MODE ===== */
  if (state.studyMode === "learn") {
    const instruction = document.createElement("div");
    instruction.className = "practice-instruction text-lg md:text-xl text-slate-700 mb-5";
    instruction.textContent = "Listen first. Then flip (click or Space) to check the meaning.";

    const whyText = (state.lang === "cy" ? (card.WhyCY || card.WhyEN) : (card.WhyEN || card.WhyCY)) || "";

    const pills = document.createElement("div");
    pills.className = "flex flex-wrap gap-2 mt-4";
    const pill = (t) => { const s = document.createElement("span"); s.className = "pill"; s.textContent = t; return s; };
    if (card.WordCategory) pills.appendChild(pill(card.WordCategory));
    if (card.Course) pills.appendChild(pill(card.Course));
    if (card.Unit) pills.appendChild(pill(card.Unit));

    const speakText = (card.BaseCY|| "").trim();
    const frontPreferred = (state.learnFront === "en") ? (card.BaseEN || "‚Äî") : (card.BaseCY || "‚Äî");
    const backText = (state.learnFront === "en") ? (card.BaseCY || "‚Äî") : (card.BaseEN || "‚Äî");

    const hideFront = !(state.learnActiveKey === cardKey && state.learnFrontReady);

    const scene = document.createElement("div");
    scene.className = "learn-scene";

    const card3d = document.createElement("div");
    card3d.id = "learnCard3d";
    card3d.className = `learn-card3d panel rounded-2xl p-6 md:p-8 shadow-sm ${state.learnFlipped ? "is-flipped" : ""}`;
    card3d.setAttribute("role", "button");
    card3d.setAttribute("tabindex", "0");
    card3d.setAttribute("aria-label", "Flashcard (click or Space to flip)");

    const front = document.createElement("div");
    front.className = "learn-face learn-front";
    front.innerHTML = `
  <div class="learn-inner">
    <div class="flex items-center justify-between gap-3">
      <div class="text-xs uppercase tracking-wide text-slate-500">Front</div>
      <button id="learnHearBtn" class="btn-hear" type="button" title="Hear (A)">
        <span class="icon" aria-hidden="true">‚ñ∂Ô∏é</span><span>Hear</span>
      </button>
    </div>

    <div id="learnFrontText" class="learn-front-text mt-6 text-4xl md:text-5xl font-bold tracking-tight text-slate-900 ${hideFront ? "is-hidden" : ""}">
      ${esc(frontPreferred)}
    </div>

    <div id="learnStatus" class="mt-2 text-xs text-slate-500"></div>

    <div class="mt-6">${pills.outerHTML}</div>

    ${whyText ? `<div class="mt-5 text-sm text-slate-700">${esc(whyText)}</div>` : ""}
    <div class="mt-6 text-xs text-slate-500">Flip to see the other side</div>
  </div>
`;


    const back = document.createElement("div");
    back.className = "learn-face learn-back";
    back.innerHTML = `
  <div class="learn-inner">
    <div class="text-xs uppercase tracking-wide text-slate-500">Back</div>
    <div class="mt-6 text-3xl md:text-4xl font-semibold text-slate-900">${esc(backText)}</div>
    ${whyText ? `<div class="mt-4 text-sm text-slate-700">${esc(whyText)}</div>` : ""}

    <div class="mt-7 flex flex-wrap gap-3">
      <button id="btnLearnAgain" class="btn btn-ghost" type="button" title="Again (1)">Again</button>
      <button id="btnLearnGood" class="btn btn-primary shadow" type="button" title="Good (2)">Good</button>
    </div>

    <div class="mt-4 text-xs text-slate-500">Again/Good updates Smart review</div>
  </div>
`;

// IMPORTANT: mount the card faces into the card, and the card into the scene
card3d.append(front, back);
scene.appendChild(card3d);

//  Click to flip (gnore clicks on buttons inside the card)
card3d.addEventListener("click", (e) => {
  if (e.target.closest("button")) return;
  toggleLearnFlip();
});

// Enter flips when the card has focus
card3d.addEventListener("keydown", (e) => {
  if (e.key === "Enter") {
    e.preventDefault();
    toggleLearnFlip();
  }
});

    wrap.append(header);
    if (hasAnyFilters) wrap.append(activeFilters);
    wrap.append(instruction, scene);
    host.appendChild(wrap);

    setTimeout(() => {
      // Ensure Space works even if focus drifted
      card3d.focus({ preventScroll: true });

      $("#learnHearBtn")?.addEventListener("click", async (e) => {
        e.stopPropagation();
        try {
          await playPollySentence(speakText);

          // After a user-initiated successful play, allow autoplay for the session (persisted)
          state.audioEnabled = true;
          saveLS("vocab_audio_enabled_v1", state.audioEnabled);

          const ft = $("#learnFrontText");
          if (ft) { ft.textContent = frontPreferred; ft.classList.remove("is-hidden"); }
          const st = $("#learnStatus");
          if (st) st.textContent = "";
          state.learnFrontReady = true;
          state.learnAutoplayBlocked = false;
        } catch (err) {
          const st = $("#learnStatus");
          if (st) st.textContent = "Couldn't play audio.";
        }
      });

      $("#btnLearnAgain")?.addEventListener("click", (e) => { e.stopPropagation(); learnRate(false); });
      $("#btnLearnGood")?.addEventListener("click", (e) => { e.stopPropagation(); learnRate(true); });

      if (speakText) startLearnAutoplay(cardKey, speakText);
    }, 0);

    return;
  }

  /* ===== TEST MODE ===== */
  const hasContext = !!(((card.BeforeCY || "").trim()) || ((card.AfterCY || "").trim()));

  const instruction = document.createElement("div");
  instruction.className = "practice-instruction text-lg md:text-xl text-slate-700 mb-5";
  if (hasContext) {
    instruction.textContent = (state.inputMode === "easy")
      ? "Choose the missing Welsh word (multiple choice)."
      : "Type the missing Welsh word.";
  } else {
    instruction.textContent = (state.inputMode === "easy")
      ? "Choose the correct Welsh translation (multiple choice)."
      : "Type the Welsh translation.";
  }

  // Base capsule (English)
  const baseBlock = document.createElement("div");
  baseBlock.className = "mb-3";

  const capsule = document.createElement("div");
  capsule.className = "inline-flex items-baseline bg-indigo-100 ring-1 ring-indigo-300 rounded-2xl px-5 py-3 shadow-sm pr-14";
  const baseSpan = document.createElement("span");
  baseSpan.className = "base-word-text text-indigo-900 text-3xl md:text-4xl font-bold tracking-tight";
  baseSpan.textContent = card.BaseEN || "‚Äî";
  capsule.appendChild(baseSpan);

  const hintParts = [];
  if (card.HintEN) hintParts.push(`<div class="base-info-meaning">${esc(card.HintEN)}</div>`);
  if (card.HintCY) hintParts.push(`<div class="base-info-meaning">${esc(card.HintCY)}</div>`);
  mountInfoPopover(capsule, hintParts.join(""), "Hint");
  baseBlock.appendChild(capsule);

  // Sentence line + input (context optional)
  const sentenceWrap = document.createElement("div");
  sentenceWrap.className = "mt-5";

  const sentenceCapsule = document.createElement("div");
  sentenceCapsule.className = "relative inline-flex flex-wrap items-baseline gap-2 pr-12 max-w-full";

  const beforeSpan = document.createElement("span");
  beforeSpan.className = "text-slate-600";
  beforeSpan.textContent = (card.BeforeCY || "").trim();

  const input = document.createElement("input");
  input.id = "answerBox";
  input.className = "border-2 border-slate-300 focus:border-cyan-600 outline-none bg-amber-50 px-3 py-2 rounded-xl text-2xl md:text-3xl leading-tight shadow-sm w-auto md:w-60 flex-shrink-0";
  input.placeholder = (state.inputMode === "easy") ? "Choose below" : "Type Welsh";
  input.setAttribute("aria-label", "Answer");
  if (state.inputMode === "easy") input.readOnly = true;

  const afterSpan = document.createElement("span");
  afterSpan.className = "text-slate-600";
  afterSpan.textContent = (card.AfterCY || "").trim();

  sentenceCapsule.append(beforeSpan, input, afterSpan);

  const sentHelp = (card.SentenceHelpEN || "").trim();
  if (sentHelp) mountInfoPopover(sentenceCapsule, `<div class="base-info-meaning">${esc(sentHelp)}</div>`, "Sentence help");

  sentenceWrap.appendChild(sentenceCapsule);

  const acceptedAnswers = Array.isArray(card.AcceptedAnswerArray) ? card.AcceptedAnswerArray
    : (Array.isArray(card.AnswerArray) ? card.AnswerArray : []);
  const canonicalAnswer = (card.AnswerCY || acceptedAnswers[0] || "").trim();

  // Easy options
  let optionList = [];
  const uniqNorm = (arr) => {
    const out = [];
    const seen = new Set();
    (arr || []).forEach(v => {
      const s = (v || "").toString().trim();
      const k = normalize(s);
      if (!k || seen.has(k)) return;
      seen.add(k);
      out.push(s);
    });
    return out;
  };

  const buildEasyOptions = () => {
    let opts = uniqNorm(Array.isArray(card.OptionsArray) ? card.OptionsArray : []);
    if (canonicalAnswer && !opts.map(normalize).includes(normalize(canonicalAnswer))) opts.unshift(canonicalAnswer);

    const target = 4;
    if (opts.length < target) {
      const poolSameCat = state.rows
        .filter(r => r.AnswerCY && r.WordCategory && r.WordCategory === card.WordCategory)
        .map(r => r.AnswerCY);

      const poolAny = state.rows
        .filter(r => r.AnswerCY)
        .map(r => r.AnswerCY);

      const pool = (poolSameCat.length >= 8) ? poolSameCat : poolAny;
      const candidates = uniqNorm(pool).filter(x => normalize(x) !== normalize(canonicalAnswer));
      shuffleInPlace(candidates);
      for (const c of candidates) {
        if (opts.length >= target) break;
        if (!opts.map(normalize).includes(normalize(c))) opts.push(c);
      }
    }
    opts = uniqNorm(opts);
    shuffleInPlace(opts);
    return opts;
  };

  if (state.inputMode === "easy" && !state.revealed) {
    if (state.easyOpt.cardKey === cardKey && Array.isArray(state.easyOpt.options) && state.easyOpt.options.length) {
      optionList = state.easyOpt.options.slice();
    } else {
      optionList = buildEasyOptions();
      state.easyOpt = { cardKey, options: optionList.slice() };
    }

    const optWrap = document.createElement("div");
    optWrap.className = "mt-4 grid grid-cols-2 gap-2 max-w-xl";

    optionList.forEach((opt) => {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "btn btn-ghost px-3 py-2 text-left";
      b.textContent = opt;
      b.addEventListener("click", () => {
        state.guess = opt;
        const ab = $("#answerBox");
        if (ab) ab.value = opt;
        ab?.focus();
      });
      optWrap.appendChild(b);
    });

    sentenceWrap.appendChild(optWrap);
  }

  // Hint box (inline)
  const hintBox = document.createElement("div");
  hintBox.className = "hidden practice-hint text-sm text-slate-600 mt-3";
  const showHint = () => {
    const first = canonicalAnswer ? canonicalAnswer.slice(0,1) : "?";
    const extra = card.HintEN ? ` ¬∑ ${card.HintEN}` : "";
    hintBox.innerHTML = `Hint: starts with <b>${esc(first)}</b>${extra ? `<span>${esc(extra)}</span>` : ""}`;
    hintBox.classList.remove("hidden");
    $("#answerBox")?.focus();
  };

  const onReveal = (resultLabel) => {
    const guess = state.guess || "";
    const ok = resultLabel === "correct";

    state.revealed = true;
    state.lastResult = resultLabel;          // "correct" | "wrong" | "skipped"
    state.freezeIdx = idxNow;
    state.freezePos = state.currentDeckPos;

    const idForStats = card.CardID || `row_${idxShown}`;
    state.history = [{
      t: Date.now(),
      ok,
      skipped: (resultLabel === "skipped"),
      cardId: idForStats,
      course: card.Course || "",
      expected: acceptedAnswers.join("|"),
      got: guess,
      mode: state.practiceMode,
      input: state.inputMode,
      study: "test"
    }, ...state.history].slice(0, 1000);
    saveLS("vocab_hist", state.history);

    updateLeitner(idForStats, ok ? "correct" : "wrong");

    const ab = $("#answerBox");
    if (ab) {
      ab.disabled = true;
      ab.classList.add("opacity-70", "cursor-not-allowed");
    }

    render();
    setTimeout(() => $("#inlineNext")?.focus({ preventScroll: true }), 0);
  };

  const onCheck = () => {
    const guess = (state.guess || "").trim();
    const ok = acceptedAnswers.some(a => normalize(a) === normalize(guess));
    onReveal(ok ? "correct" : "wrong");
  };

  const onSkip = () => {
    // Skip counts as wrong: reveal answer, record wrong, then Next.
    state.guess = "";
    onReveal("skipped");
  };

  // Actions: ONLY before reveal, so there is no confusing Next button.
  const actions = document.createElement("div");
  actions.className = "practice-actions flex flex-wrap gap-3 mt-4";

  if (!state.revealed) {
    const btnCheck = document.createElement("button");
    btnCheck.type = "button";
    btnCheck.id = "btnCheck";
    btnCheck.className = "btn btn-primary shadow";
    btnCheck.textContent = "Check";
    btnCheck.onclick = onCheck;

    const btnHint = document.createElement("button");
    btnHint.type = "button";
    btnHint.id = "btnHint";
    btnHint.className = "btn btn-ghost";
    btnHint.textContent = "Hint";
    btnHint.onclick = showHint;

    const btnSkip = document.createElement("button");
    btnSkip.type = "button";
    btnSkip.id = "btnSkip";
    btnSkip.className = "btn btn-ghost";
    btnSkip.textContent = "Skip";
    btnSkip.onclick = onSkip;

    actions.append(btnCheck, btnHint, btnSkip);
  }

  // Feedback (includes Hear + Next)
  const feedback = document.createElement("div");
  feedback.className = "practice-feedback mt-4";
  feedback.setAttribute("aria-live", "polite");

  if (state.revealed) {
    const ok = state.lastResult === "correct";
    const skipped = state.lastResult === "skipped";

    const statusIcon = skipped ? "‚è≠Ô∏è" : (ok ? "‚úÖ" : "‚ùå");
    const statusText = skipped ? "Skipped (counts as wrong)" : (ok ? "Correct!" : "Not quite");

    const fullSentence = buildCompleteSentence(card, canonicalAnswer);
    const whyText = (state.lang === "cy" ? (card.WhyCY || card.WhyEN) : (card.WhyEN || card.WhyCY)) || "";

    feedback.innerHTML = `
      <div class="feedback-box">
        <div class="flex items-center gap-2 ${ok ? "text-indigo-900" : "text-rose-900"} text-2xl md:text-3xl font-semibold">
          ${statusIcon} ${esc(statusText)}
        </div>

        ${(!ok && !skipped)
          ? `<div class="mt-1 text-slate-700">You typed: <b>${esc(state.guess) || "(blank)"}</b></div>`
          : ""
        }

        <div class="mt-4 text-slate-800 text-xl md:text-2xl flex items-baseline flex-wrap gap-x-3 gap-y-2">
          <span>${esc(card.BeforeCY || "")}</span>
          <span class="font-semibold bg-indigo-100 text-indigo-900 px-1 rounded">${esc(canonicalAnswer)}</span>
          <span>${esc(card.AfterCY || "")}</span>

          <button id="btnHear" class="btn-hear" type="button">
            <span class="icon" aria-hidden="true">‚ñ∂Ô∏é</span>
            <span>Hear</span>
          </button>
        </div>

        ${whyText ? `<div class="mt-4 text-slate-700">${esc(whyText)}</div>` : ""}

        <div class="mt-4 flex justify-end">
          <button id="inlineNext" class="btn btn-primary shadow transition" type="button" title="Next (Enter)">
            Next
          </button>
        </div>
      </div>
    `;

    setTimeout(() => {
      $("#btnHear")?.addEventListener("click", async () => {
        try { await playPollySentence(fullSentence); }
        catch (e) { alert("Couldn't play audio: " + (e?.message || e)); }
      });
      $("#inlineNext")?.addEventListener("click", () => nextCard(1));
    }, 0);
  }

  wrap.append(header);
  if (hasAnyFilters) wrap.append(activeFilters);
  wrap.append(instruction, baseBlock, sentenceWrap, actions, hintBox, feedback);
  host.appendChild(wrap);

  const ab = $("#answerBox");
  if (ab) {
    ab.value = state.guess;
    ab.focus();

    ab.addEventListener("keydown", (e) => {
      if (e.key === "Enter") {
        e.preventDefault(); e.stopPropagation();
        if (!state.revealed) onCheck();
        else $("#inlineNext")?.click();
      }

      if (state.inputMode === "easy") {
        const k = e.key;
        if (["1","2","3","4"].includes(k) && Array.isArray(optionList) && optionList.length) {
          const idx = Number(k) - 1;
          if (optionList[idx]) { state.guess = optionList[idx]; ab.value = optionList[idx]; }
        }
      }
    });

    ab.addEventListener("input", (e) => {
      if (state.inputMode === "easy") return;
      state.guess = e.target.value;
    });
  }
}

function renderBrowse() {
  const head = $("#browseHead");
  const body = $("#browseBody");
  if (!head || !body) return;

  head.innerHTML = "";
  body.innerHTML = "";

  const cols = ["Course","Unit","WordCategory","BaseEN","BeforeCY","AfterCY","AnswerCY","AnswerArray","Tags","WhyEN"];
  cols.forEach(h => {
    const th = document.createElement("th");
    th.className = "text-left p-2 border-b";
    th.textContent = h;
    head.appendChild(th);
  });

  state.filtered.forEach((r, i) => {
    const tr = document.createElement("tr");
    tr.className = (i % 2 ? "bg-white" : "bg-slate-50");
    cols.forEach(k => {
      const td = document.createElement("td");
      td.className = "p-2 align-top";
      let val = r[k] || "";
      if (k === "AnswerArray") val = Array.isArray(r.AnswerArray) ? r.AnswerArray.join(" | ") : "";
      td.textContent = val;
      tr.appendChild(td);
    });
    body.appendChild(tr);
  });
}

function computeStats() {
  const total = state.history.length;
  const correct = state.history.filter(h => h.ok).length;
  const acc = total ? Math.round((correct / total) * 100) : 0;

  const by = {};
  for (const h of state.history) {
    const c = h.course || "(unknown)";
    by[c] = by[c] || { total: 0, ok: 0 };
    by[c].total++;
    if (h.ok) by[c].ok++;
  }
  return { total, correct, acc, by };
}

function renderStatsPanels() {
  const s = computeStats();
  $("#accBig").textContent = `${s.acc}%`;
  $("#accText").textContent = `${s.correct} / ${s.total} correct`;
  $("#statsAcc").textContent = `${s.acc}%`;
  $("#statsText").textContent = `${s.correct} correct out of ${s.total}`;

  const ul1 = $("#byCourse");
  const ul2 = $("#statsByCourse");
  if (ul1) ul1.innerHTML = "";
  if (ul2) ul2.innerHTML = "";

  Object.entries(s.by)
    .sort((a,b) => (b[1].total - a[1].total))
    .forEach(([k, v]) => {
      const li1 = document.createElement("li");
      li1.className = "flex justify-between";
      li1.innerHTML = `<span>${esc(k)}</span><span class="text-slate-600">${v.ok}/${v.total}</span>`;
      ul1.appendChild(li1);

      const li2 = document.createElement("li");
      li2.className = "flex justify-between";
      li2.innerHTML = `<span>${esc(k)}</span><span class="text-slate-600">${v.ok}/${v.total}</span>`;
      ul2.appendChild(li2);
    });
}

function render() {
  setMobileBarForMode();
  $("#practiceView")?.classList.toggle("hidden", state.mode !== "practice");
  $("#browseView")?.classList.toggle("hidden", state.mode !== "browse");
  $("#statsView")?.classList.toggle("hidden", state.mode !== "stats");

  if (state.mode === "practice") renderPractice();
  if (state.mode === "browse") renderBrowse();
  renderStatsPanels();
}

function nextCard(offset = 1) {
  state.easyOpt = { cardKey: null, options: [] };

  const useSmart = isSmartActive();
  if (useSmart) {
    if (!state.filtered.length) return;
    state.freezeIdx = null;
    state.freezePos = null;
    state.smartIdx = pickNextSmartIdx();
    state.smartCount = (state.smartCount || 0) + 1;
    state.guess = "";
    state.revealed = false;
    state.lastResult = null;
    resetLearnStateForNewCard();
    render();
    return;
  }

  if (!state.deck.length) return;

  // In TEST mode only: if wrong OR skipped, bring it back again soon.
  if (state.studyMode === "test" && (state.lastResult === "wrong" || state.lastResult === "skipped") && state.freezeIdx != null && state.freezePos != null) {
    const idxVal = state.freezeIdx;
    let deckPos = state.freezePos;
    if (state.deck[deckPos] !== idxVal) deckPos = state.deck.indexOf(idxVal);
    if (deckPos >= 0) {
      const newDeck = state.deck.slice();
      newDeck.splice(deckPos, 1);
      const insertAt = Math.min(deckPos + 3, newDeck.length);
      newDeck.splice(insertAt, 0, idxVal);
      state.deck = newDeck;
    }
  }

  state.freezeIdx = null;
  state.freezePos = null;
  state.p = (state.p + offset + state.deck.length) % state.deck.length;
  state.guess = "";
  state.revealed = false;
  state.lastResult = null;

  resetLearnStateForNewCard();
  render();
}

/* ========= Event wiring ========= */
function wireUi() {
  $("#btnPractice")?.addEventListener("click", () => { state.mode = "practice"; saveLS("vocab_mode", state.mode); render(); });
  $("#btnBrowse")?.addEventListener("click",   () => { state.mode = "browse";   saveLS("vocab_mode", state.mode); render(); });
  $("#btnStats")?.addEventListener("click",    () => { state.mode = "stats";    saveLS("vocab_mode", state.mode); render(); });

  $("#btnFilters")?.addEventListener("click", () => {
    const p = $("#filtersPanel");
    if (!p) return;
    p.classList.toggle("hidden");
    // If we just hid filters, return focus to flashcard so Space works
    if (p.classList.contains("hidden") && state.mode === "practice" && state.studyMode === "learn") {
      setTimeout(() => $("#learnCard3d")?.focus({ preventScroll: true }), 0);
    }
  });

  $("#btnHelp")?.addEventListener("click", () => { $("#onboard")?.classList.remove("hidden"); window.scrollTo({ top: 0, behavior: "smooth" }); });

  $("#btnLangToggle")?.addEventListener("click", () => {
    state.lang = (state.lang === "en") ? "cy" : "en";
    saveLS("vocab_lang", state.lang);
    render();
    applyLanguage();
  });

  $("#onboardFilters")?.addEventListener("click", () => {
    $("#onboard")?.classList.add("hidden");
    $("#filtersPanel")?.classList.remove("hidden");
    window.scrollTo({ top: 0, behavior: "smooth" });
  });
  $("#onboardDismiss")?.addEventListener("click", () => $("#onboard")?.classList.add("hidden"));

  $("#btnResetStats")?.addEventListener("click", () => { state.history = []; saveLS("vocab_hist", state.history); render(); });
  $("#btnResetStats2")?.addEventListener("click", () => { state.history = []; saveLS("vocab_hist", state.history); render(); });

  $("#btnTop")?.addEventListener("click", () => window.scrollTo({ top: 0, behavior: "smooth" }));

  document.addEventListener("keydown", (e) => {
    const tag = (e.target && e.target.tagName) || "";
    if (["INPUT", "TEXTAREA", "SELECT", "BUTTON", "A"].includes(tag.toUpperCase())) return;
    if (state.mode !== "practice") return;

if (state.studyMode === "learn") {
  const k = e.key;

  // Space: flip; if already flipped, advance
  if (k === " " || k === "Spacebar") {
    e.preventDefault();

    if (!state.learnFlipped) {
      toggleLearnFlip(true);
    } else {
      // If Smart is active, treat advance as "Good" so Leitner still works
      if (isSmartActive()) learnRate(true);
      else nextCard(1);
    }
    return;
  }

  if (k.toLowerCase() === "a") { e.preventDefault(); $("#learnHearBtn")?.click(); return; }
  if (k === "1") { e.preventDefault(); learnRate(false); return; }
  if (k === "2") { e.preventDefault(); learnRate(true); return; }

  if (k === "Enter" || k === "ArrowRight" || k.toLowerCase() === "n") {
    e.preventDefault();
    if (isSmartActive()) learnRate(true);
    else nextCard(1);
    return;
  }

  if (k === "ArrowLeft" || k.toLowerCase() === "p") {
    e.preventDefault();
    // No true "prev" in Smart mode
    if (!isSmartActive()) nextCard(-1);
    return;
  }

  if (k.toLowerCase() === "f") { e.preventDefault(); $("#btnFilters")?.click(); return; }
  return;
}



    // Test mode keyboard
    if (e.key === "Enter") {
      e.preventDefault();
      if (!state.revealed) $("#btnCheck")?.click();
      else $("#inlineNext")?.click();
    } else if (e.key.toLowerCase() === "h") {
      $("#btnHint")?.click();
    } else if (e.key.toLowerCase() === "f") {
      $("#btnFilters")?.click();
    } else if (e.key.toLowerCase() === "s") {
      // Skip shortcut
      if (!state.revealed) $("#btnSkip")?.click();
    }
  });

  // Mobile bar wiring
  $("#mbHint")?.addEventListener("click", () => {
    if (state.studyMode === "learn") $("#learnHearBtn")?.click();
    else {
      if (!state.revealed) $("#btnHint")?.click();
      else $("#btnHear")?.click();
    }
  });
  $("#mbCheck")?.addEventListener("click", () => {
    if (state.studyMode === "learn") learnRate(false);
    else {
      if (!state.revealed) $("#btnCheck")?.click();
      else $("#inlineNext")?.click();
    }
  });
  $("#mbNext")?.addEventListener("click", () => {
    if (state.studyMode === "learn") learnRate(true);
    else {
      if (!state.revealed) $("#btnSkip")?.click();
    }
  });

  if (state.admin) {
    $("#adminBadge")?.classList.remove("hidden");
    $("#adminPanel")?.classList.remove("hidden");

    const dataUrl = $("#dataUrl");
    if (dataUrl) dataUrl.value = getParam("sheet") || "";

    $("#btnLoadUrl")?.addEventListener("click", async () => {
      const u = ($("#dataUrl")?.value || "").trim();
      if (!u) return;
      const d = await loadCsvUrl(u);
      state.rows = d.map(coerceRow).filter(r => r.BaseEN && r.AnswerCY);
      applyFilters(); rebuildDeck(); buildFilterControls(); render();
    });

    $("#fileCsv")?.addEventListener("change", (e) => {
      const f = e.target.files?.[0];
      if (!f) return;
      Papa.parse(f, {
        header: true,
        skipEmptyLines: true,
        complete: (res) => {
          state.rows = res.data.map(coerceRow).filter(r => r.BaseEN && r.AnswerCY);
          applyFilters(); rebuildDeck(); buildFilterControls(); render();
        }
      });
    });
  }
}

/* ========= Boot ========= */
async function initData() {
  const sheet = getParam("sheet");
  let rows = [];
  try {
    rows = sheet ? await loadCsvUrl(sheet) : await loadDefaultCsv();
  } catch (e) {
    console.warn("Data load failed; trying fallback", e);
    rows = await loadDefaultCsv();
  }

  state.rows = rows.map(coerceRow).filter(r => r.BaseEN && r.AnswerCY);

  const itemCountEl = $("#itemCount");
  if (itemCountEl) {
    itemCountEl.textContent = `${state.rows.length} items`;
    itemCountEl.classList.remove("hidden");
  }

  applyFilters();
  rebuildDeck();
  buildFilterControls();
  render();
}

(async function boot() {
  wireUi();
  applyLanguage();
  await initData();
})();
</script>

</body>
</html>

